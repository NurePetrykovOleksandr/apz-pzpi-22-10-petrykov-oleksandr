МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ

ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ
УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ

Кафедра «Програмна інженерія»


ЗВІТ
до практичної роботи №1 з дисципліни
 «Архітектура програмного забезпечення»
На тему: «Патерн проектування Template Method»



Виконав:                                              		       Перевірив:
ст. гр. ПЗПІ-22-10 				               cт. в. каф. ПІ 
Петриков О. Д.	                                                 Сокорчук  І. П.    






Харків 2025
ІСТОРІЯ ЗМІН

№ 
Дата
Версія звіту
 Опис змін та виправлень
1
10.06.2025
0.1
Створення  та заповнення розділів: «Завдання»,  «Опис виконаної роботи», «Висновки»
2
12.06.2025
0.2
Додано фото слайдів презентації, додано посилання на відеозапис та розписано хронологію відео з описом


ЗАВДАННЯ

Підготувати доповідь на тему: «Шаблон (патерн) проєктування ПЗ»
(із книг: Ґамма, “ООП. Патерни проєктування”, GoF, крім патерна Singletone)
Створити та оформити слайди презентації доповіді
Створити та опублікувати на YouTube відеозапис доповіді
Оформити та завантажити на dl.nure.ua звіт до виконаної роботи
При потребі створити та налаштувати у GitHub обліковий запис для облікового запису студента в домені @nure.ua
Створити для виконання завдань з дисципліни GitHub репозиторій iз вказаним на https://dl.nure.ua іменем та з головною гілкою main
Створити у корені створеного репозиторію файл README.md з вказаним далі змістом та вказані далі директорії для окремих завдань
Експортувати звіт у файл у простому текстововому форматі та завантажити цей файл у директорію Pract1 у репозиторії GitHub
Завантажити у вказану далі піддиректорію увесь програмний код, який розглядається у доповіді ПЗ1. 
ОПИС ВИКОНАНОЇ РОБОТИ
У межах виконання лабораторної роботи було проведено ґрунтовне дослідження патерну проектування Template Method (Шаблонний метод), який належить до поведінкових патернів. Основна увага приділялась аналізу структури патерну, його ключових ролей, механізмів спадкування та варіантів розширення за допомогою підкласів. Теоретичну частину дослідження засновано на класичних джерелах, зокрема книзі "Design Patterns: Elements of Reusable Object-Oriented Software" та на матеріалах із відкритих навчальних ресурсів.
Проведено аналіз проблем, які вирішує патерн Template Method у контексті повторного використання коду, усунення дублікатів та контролю структури алгоритмів. Було представлено UML-діаграму, що демонструє взаємозв’язки між абстрактним класом (AbstractClass) і конкретними реалізаціями (ConcreteClass), а також механізм виклику кроків алгоритму через шаблонний метод.
Для закріплення теоретичних знань реалізовано приклад абстрактного класу DataProcessor, який містить шаблонний метод process(), і конкретного підкласу CSVProcessor, що перевизначає окремі кроки обробки даних. Застосування шаблонного методу в коді дозволило продемонструвати, як забезпечується повторне використання логіки, її стандартизація та контрольоване розширення.
У процесі аналізу порівняно Template Method з іншими патернами, зокрема Strategy, Factory Method та Command, з метою виявлення їх спільних і відмінних рис. Досліджено також практичні рекомендації щодо ефективної реалізації патерну та типові помилки, яких слід уникати.
ВИСНОВКИ
У результаті виконання лабораторної роботи було сформовано глибоке розуміння патерну проектування Template Method як ефективного інструменту повторного використання поведінки у базовому класі з можливістю адаптації кроків алгоритму в підкласах. Патерн забезпечує чітку структуру виконання операцій, сприяє дотриманню принципів DRY (Don't Repeat Yourself) і Open/Closed Principle, дозволяє зменшити дублювання коду та покращити підтримуваність програмної системи.
Разом із перевагами Template Method має і низку обмежень, зокрема жорстку фіксацію порядку виконання кроків та потенційне ускладнення коду в разі надмірного використання абстракцій. Проте за правильного застосування цей патерн є ефективним засобом для організації стабільної та гнучкої логіки в об’єктно-орієнтованих програмах.
Набуті знання будуть використані при проектуванні програмних систем, де важливо стандартизувати алгоритми з можливістю модифікації окремих кроків без зміни загальної структури, зокрема у фреймворках, інструментах обробки даних, UI-бібліотеках тощо.

ДОДАТОК А

Відеозапис доповіді на YouTube: https://youtu.be/yQNngumL2sk
00:00 - Вступ 
00:13 - що таке  template method
00:42 - типові проблеми
01:18 - проблема 1
01:33 - вирішення проблеми 1
01:48 - проблема 2
02:04 - вирішення проблеми 2
02:21 - коли використовувати
02:55- Недоліки патерну
03:27 - Переваги патерну
03:56- Висновки
04:12- Список літератури
04:50 -  Дякую за увагу!

ДОДАТОК Б




Рисунок Б.1-  Вступ

Рисунок Б.2-  що таке  template method

Рисунок Б.3 -  типові проблеми

Рисунок Б.4 - проблема 1

Рисунок Б.5 - вирішення проблеми 1

Рисунок Б.6 - проблема 2

Рисунок Б.7 - вирішення проблеми 2

Рисунок Б.8 - коли використовувати

Рисунок Б.9 - Недоліки патерну

Рисунок Б.10 - Переваги патерну

Рисунок Б.11 - Висновки

Рисунок Б.12 - Список літератури

Рисунок Б.13 - Дякую за увагу

ДОДАТОК В
Приклад коду
// ====== До: дублювання логіки ======
1  class TeaMaker {
2  public:
3      void prepare() {
4          std::cout << "Boil water" << std::endl;
5          std::cout << "Steep the tea" << std::endl;
6          std::cout << "Pour into cup" << std::endl;
7          std::cout << "Add lemon" << std::endl;
8      }
9  };
10 
11 class CoffeeMaker {
12 public:
13     void prepare() {
14         std::cout << "Boil water" << std::endl;
15         std::cout << "Brew coffee grounds" << std::endl;
16         std::cout << "Pour into cup" << std::endl;
17         std::cout << "Add sugar and milk" << std::endl;
18     }
19 };
// ====== Після: застосування Template Method ======
20 
21 class CaffeineBeverage {
22 public:
23     void prepare() {
24         boilWater();
25         brew();
26         pourInCup();
27         addCondiments();
28     }
29 
30 protected:
31     void boilWater() {
32         std::cout << "Boil water" << std::endl;
33     }
34 
35     void pourInCup() {
36         std::cout << "Pour into cup" << std::endl;
37     }
38 
39     virtual void brew() = 0;
40     virtual void addCondiments() = 0;
41 };
42 
43 class Tea : public CaffeineBeverage {
44 protected:
45     void brew() override {
46         std::cout << "Steep the tea" << std::endl;
47     }
48 
49     void addCondiments() override {
50         std::cout << "Add lemon" << std::endl;
51     }
52 };
53 
54 class Coffee : public CaffeineBeverage {
55 protected:
56     void brew() override {
57         std::cout << "Brew coffee grounds" << std::endl;
58     }
59 
60     void addCondiments() override {
61         std::cout << "Add sugar and milk" << std::endl;
62     }
63 };

# ====== До: дублювання логіки ======
64 class PDFProcessor:
65     def process(self):
66         print("Open file")
67         print("Process PDF")
68         print("Save file")
69         print("Close file")

70 class XMLProcessor:
71     def process(self):
72         print("Open file")
73         print("Process XML")
74         print("Save file")
75         print("Close file")

76 class CSVProcessor:
77     def process(self):
78         print("Open file")
79         print("Process CSV")
80         print("Save file")
81         print("Close file")

# ====== Після: застосування Template Method ======
82 from abc import ABC, abstractmethod

83 class FileProcessor(ABC):
84     def process(self):
85         self.open_file()
86         self.process_file()
87         self.save_file()
88         self.close_file()

89     def open_file(self):
90         print("Open file")

91     def save_file(self):
92         print("Save file")

93     def close_file(self):
94         print("Close file")

95     @abstractmethod
96     def process_file(self):
97         pass

98 class PDFProcessor(FileProcessor):
99     def process_file(self):
100        print("Process PDF")

101 class XMLProcessor(FileProcessor):
102    def process_file(self):
103        print("Process XML")

104 class CSVProcessor(FileProcessor):
105    def process_file(self):
106        print("Process CSV")



